# -*- coding: utf-8 -*-
"""HextoVec.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GcRJ-3vtNPd6z7nJtodo6GZVOmk95vva
"""

from google.colab import drive
drive.mount('/content/gdrive')

"""Tham kháº£o: https://gist.github.com/lttn1204/0ee0d5fc05729876d403bd5d48ca5d7d

##Install lib
"""

!pip install pyvex
!pip install matplotlib-venn
!pip install archinfo
!pip install bitstring
!pip install angr
!pip install analyse

import pyvex
import archinfo
import re
import hashlib
import os
import random
import pickle

# this function to get all variable of one statement and it's type (define or reference)
def get_var_in_stmt(stmt):
    res=[]
    # regular expression pattern to match temporary variables
    pattern = r't\d+'
    variables = re.findall(pattern, stmt)
    if stmt[:2]=='if':
        res.append([variables[0],'ref'])
        return res
    if len(variables)==0:
        return []
    eql=stmt.index('=')
    for var in variables:
        if stmt.index(var)<eql:
            res.append([var,'def'])
        else:
            res.append([var,'ref'])
    return res

# this function detect a statement ca be propagation or not
def dectect_which_statement_can_be_propagation(stmt):
    vars=get_var_in_stmt(stmt)
    if len(stmt)<10 and len(vars)==2 and vars[0][1]=='def' and vars[1][1]=='ref':
        return True
    return False

# implement dead code elimination in a block
def dead_code_elimination(block):
    res=[]
    for i in range(len(block)):
        if dectect_which_statement_can_be_propagation(block[i])==False:
            res.append(block[i])
    return res
# this function return reference variable in a statement in basic block
def reference(stmt):
    res=[]
    vars=get_var_in_stmt(stmt)
    for var in vars:
        if var[1]=='ref':
            res.append(var[0])
    return res

# this function return define variable in a statement in basic block
def define(stmt):
    res=[]
    vars=get_var_in_stmt(stmt)
    for var in vars:
        if var[1]=='def':
            res.append(var[0])
    return res

# this function return intersection of 2 list of variables
def intersect(vars1,vars2):
    for var in vars1:
        if var in vars2:
            return True
    return False


# this function return union of 2 list of variables
def union(vars1,vars2):
    res=[]
    for var in vars1:
        res.append(var)
    for var in vars2:
        res.append(var)
    return res

def parse_bb_to_strand(block):
    S=[]
    uncovered=list(range(len(block)))
    #print(uncovered)
    while len(uncovered)>0:
        last=uncovered.pop()
        strand=[block[last]]
        used=reference(block[last])
        for i in range(last-1,-1,-1):
            #print(f" i: {i}")
            #print(f"block:  {block[i]}")
            needed=intersect(used,define(block[i]))
            #print(f"define: {define(block[i])}")
            if needed==True:
                #print("found")
                strand.append(block[i])
                used= union(reference(block[i]),used)
                #print(f"used: {used}")
                #print(f" i: {uncovered}")
                try:
                    uncovered.remove(i)
                except:
                    continue
                #print(f" i: {uncovered}")
        S.append(strand)
    return S

def copy_propagation(block):
    ACP={}
    res=[]
    for i in range(len(block)):
        #print("block: ", block[i])
        stmt=block[i]
        vars=get_var_in_stmt(stmt)[::-1]
        #print("vars:", vars)
        for var in vars:
            #print(var)
            if var[1]=='ref' and var[0] in ACP.keys():
                #print("replace", var[0],ACP[var[0]])
                stmt=stmt.replace(var[0],ACP[var[0]])
                #print("stmt: ", stmt)
            if var[1]=='def' and var[0] in ACP.keys():
                #print("dell",ACP[var[0]])
                del ACP[var[0]]
        if dectect_which_statement_can_be_propagation(stmt)==True:
            vars=get_var_in_stmt(stmt)
            ACP[vars[0][0]]=vars[1][0]
            #print("ACP:",ACP)
        res.append(stmt)
        #print("----------------------")
    return res

# implement dead code elimination in a block
def dead_code_elimination(block):
    res=[]
    for i in range(len(block)):
        if dectect_which_statement_can_be_propagation(block[i])==False:
            res.append(block[i])
    return res

# this funtion normalize a basic block, rename all temporary variables in descending chronological order
def normalize(block):

    mapping={}
    pattern = r't\d+'
    all_stmt="\n".join(block)
    if get_var_in_stmt(all_stmt)==[]:
        return block
    print(all_stmt)
    variables = re.findall(pattern, all_stmt)
    variables = list(dict.fromkeys(variables))

    for i in range(len(variables)):
        mapping[variables[i]]='t'+str(i)
    print(mapping)
    def new_replace(match):
        return mapping[match.group(0)]

    pattern = re.compile('|'.join(map(re.escape, mapping.keys())))
    result = pattern.sub(new_replace, all_stmt)
    print("---------------------")

    print("---------------------")
    print(result)
    return result

# this function return vector from a list of strand
def extract_vector_from_strand(liststrand, size):
    vector=[0]*size
    print("Hash values:\n")
    for strand in liststrand:
        value=int(hashlib.md5(str(strand).encode()).hexdigest(),16)%2**10
        print(value)
        vector[value]+=1
    return vector

def get_vexIR(raw_bytes):
    irsb = pyvex.IRSB(data=raw_bytes, mem_addr=0x08048429, arch=archinfo.ArchX86())
    result=b''
    for stmt in irsb.statements:
        if not isinstance(stmt, pyvex.IRStmt.IMark):
            result+=(str(stmt).encode()+b'\n')
    return result.decode()

def process_a_func(raw_bytes,size):
    vex_ir=get_vexIR(raw_bytes)

    block=vex_ir.split("\n")[:-1]

    strand=parse_bb_to_strand(block)

    res=[]
    for i in strand:
        res.append(copy_propagation(i))
    strand=res

    res=[]
    for i in strand:
        res.append(dead_code_elimination(i))
    strand=res

    res=[]
    for i in strand:
        res.append(normalize(i))
    strand=res

    vector=extract_vector_from_strand(strand,size)

    print("Vector:\n ",vector)

data = bytes.fromhex("4d 5a 90000300000004000000ffff0000b800000000000000400000000000000000000000000000000000000000000000000000000000000000000000f80000000e1fba0e00b409cd21b8014ccd21546869732070726f6772616d2063616e6e6f742062652072756e20696e20444f53206d6f64652e0d0d0a24000000000000003876adf97c17c3aa7c17c3aa7c17c3aa756f50aa7a17c3aa7c17c2aa5417c3aa376fc2ab7517c3aa376fc7ab6e17c3aa376fc0ab7f17c3aa376fcbab7f17c3aa376fc6ab7e17c3aa376f3caa7d17c3aa376fc1ab7d17c3aa526963687c17c3aa00000000000000000000")
vector_size = 1000
process_a_func(data, vector_size)

with open('/content/gdrive/MyDrive/calc_rawbyte.txt', 'r') as file:
    hex_string = file.read().strip()
print(hex_string)
data = bytes.fromhex(hex_string)
print(data)
vector_size = 1000
process_a_func(data, vector_size)